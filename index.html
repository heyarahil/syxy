<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Typography Scroll Up</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
    <style>
        @font-face {
            font-family: "Comforter Brush";
            src: url("fonts/ComforterBrush-Regular.woff") format("woff");
            font-display: swap;
        }

        html,
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: black;
            overscroll-behavior: none;
            touch-action: none;
        }
        canvas {
            display: block;
        }

        .play-button {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            padding: 3rem;
            background: #000000;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 0 100vmax #000000;
        }

        @media (max-width: 820px) {
            .play-button {
                padding: 2.5rem;
            }
        }

        @media (max-width: 480px) {
            .play-button {
                padding: 2rem;
            }
        }

        .play-button img {
            width: min(28vw, 28rem);
            max-width: 90vw;
            height: auto;
            display: block;
            filter: drop-shadow(0 4px 12px rgba(0, 0, 0, 0.4)) grayscale(100%) contrast(1.2) brightness(1.1);
        }

        @media (max-width: 820px) {
            .play-button img {
                width: min(70vw, 40rem);
            }
        }

        @media (max-width: 480px) {
            .play-button img {
                width: min(80vw, 45rem);
            }
        }

        .play-button:focus-visible {
            outline: none;
        }

        .music-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 9;
            pointer-events: none;
            width: 1px;
            height: 1px;
        }

        .music-icon {
            position: absolute;
            opacity: 0;
            animation: music-fly 2.5s ease-out forwards;
        }

        .music-icon svg {
            width: clamp(2rem, 4vw, 3.5rem);
            height: clamp(2rem, 4vw, 3.5rem);
            fill: #ff69b4;
            filter: drop-shadow(0 2px 4px rgba(255, 105, 180, 0.4));
        }

        @keyframes music-fly {
            0% {
                opacity: 0;
                transform: translate(0, 0) rotate(0deg) scale(0.3);
            }
            15% {
                opacity: 1;
            }
            100% {
                opacity: 0;
                transform: translate(var(--music-x), var(--music-y)) rotate(var(--music-rot)) scale(1.3);
            }
        }
    </style>
</head>
<body>
    <div class="music-container" id="music-container"></div>
    <button class="play-button" id="play-button" aria-label="Play">
        <img src="Photoroom_20251118_232501.png" alt="Play button" />
    </button>
    <script>
        const playButton = document.getElementById("play-button");
        const musicContainer = document.getElementById("music-container");
        let musicInterval;
        
        // Simple music SVG icons
        const musicIcons = [
            // Music Note 1
            '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 3V13.55C11.41 13.21 10.73 13 10 13C7.79 13 6 14.79 6 17S7.79 21 10 21 14 19.21 14 17V7H18V3H12Z"/></svg>',
            // Music Note 2
            '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M16 9V7H12V17.5C12 19.43 10.43 21 8.5 21S5 19.43 5 17.5 6.57 14 8.5 14C9.35 14 10.13 14.28 10.76 14.76V5H16V3H18V9H16Z"/></svg>',
            // Microphone 1
            '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 2A3 3 0 0 0 9 5V11A3 3 0 0 0 12 14A3 3 0 0 0 15 11V5A3 3 0 0 0 12 2M19 11C19 14.53 16.39 17.44 13 17.93V21H11V17.93C7.61 17.44 5 14.53 5 11H7A5 5 0 0 0 12 16A5 5 0 0 0 17 11H19Z"/></svg>',
            // Microphone 2
            '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 2C10.9 2 10 2.9 10 4V12C10 13.1 10.9 14 12 14S14 13.1 14 12V4C14 2.9 13.1 2 12 2M18 11C18 14.53 15.39 17.44 12 17.93V21H10V17.93C6.61 17.44 4 14.53 4 11H6C6 13.76 8.24 16 11 16H13C15.76 16 18 13.76 18 11H20C20 13.37 18.39 15.38 16.2 16.27C16.55 16.73 16.86 17.23 17.09 17.77C19.66 16.47 21.5 13.91 21.5 11H18Z"/></svg>',
            // Musical notes
            '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M14 3V7H16V3M16 17V11H14V17C13.4 17 13 17.4 13 18S13.4 19 14 19 15 18.6 15 18 14.6 17 14 17M8 3V13.6C7.4 13.2 6.7 13 6 13C3.8 13 2 14.8 2 17S3.8 21 6 21 10 19.2 10 17V7H12V3M18 15V21H20V15M20 7V9H18V7H20Z"/></svg>',
            // Headphones music
            '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 3C7.03 3 3 7.03 3 12V19C3 20.66 4.34 22 6 22H9V15H5V12C5 8.13 8.13 5 12 5S19 8.13 19 12V15H15V22H18C19.66 22 21 20.66 21 19V12C21 7.03 16.97 3 12 3Z"/></svg>'
        ];
        
        // Create audio context for twinkling sound
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let audioCtx;

        function playTwinkle() {
            if (!audioCtx) {
                audioCtx = new AudioContext();
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }

            const now = audioCtx.currentTime;
            
            // Create multiple oscillators for a sparkly chord
            [0, 0.1, 0.2].forEach((delay, i) => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                
                // High pitched sine waves
                osc.type = 'sine';
                // Pentatonic-ish notes: C6, D6, E6
                const freqs = [1046.50, 1174.66, 1318.51]; 
                osc.frequency.setValueAtTime(freqs[i] + (Math.random() * 20 - 10), now + delay);
                
                // Envelope
                gain.gain.setValueAtTime(0, now + delay);
                gain.gain.linearRampToValueAtTime(0.1, now + delay + 0.05);
                gain.gain.exponentialRampToValueAtTime(0.001, now + delay + 0.4);
                
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                
                osc.start(now + delay);
                osc.stop(now + delay + 0.5);
            });
        }

        function spawnMusicIcon() {
            const musicIcon = document.createElement('div');
            musicIcon.className = 'music-icon';
            
            // Pick random icon
            const randomIcon = musicIcons[Math.floor(Math.random() * musicIcons.length)];
            musicIcon.innerHTML = randomIcon;
            
            // Random trajectory
            const angle = Math.random() * Math.PI * 2;
            const distance = 200 + Math.random() * 300;
            const musicX = Math.cos(angle) * distance;
            const musicY = Math.sin(angle) * distance;
            const musicRot = Math.random() * 360 - 180;
            
            musicIcon.style.setProperty('--music-x', `${musicX}px`);
            musicIcon.style.setProperty('--music-y', `${musicY}px`);
            musicIcon.style.setProperty('--music-rot', `${musicRot}deg`);
            
            musicContainer.appendChild(musicIcon);
            
            // Remove after animation
            setTimeout(() => {
                if (musicIcon.parentNode) {
                    musicIcon.remove();
                }
            }, 2500);
        }

        function startMusic() {
            spawnMusicIcon();
            musicInterval = setInterval(spawnMusicIcon, 200);
        }

        function stopMusic() {
            if (musicInterval) {
                clearInterval(musicInterval);
                musicInterval = null;
            }
        }

        playButton.addEventListener("mouseenter", () => {
            playTwinkle();
            startMusic();
        });

        playButton.addEventListener("mouseleave", () => {
            stopMusic();
        });

        playButton.addEventListener("click", () => {
            window.location.href = "play.html";
        });

        const phrase = "Syxy ";
        let particles = [];
        let customFont;
        let fontLoaded = false;
        let fontSize;
        let rowSpacing;
        let columnWidth;
        let totalScrollHeight = 0;
        let columns = 3;
        let rowsPerColumn = 0;
        const scrollSpeed = 3.1;
        const desktopSpacingFactor = 0.82;
        const mobileSpacingFactor = 0.78;
        const mobileBreakpoint = 820;
        const minColumns = 2;
        const maxColumns = 5;
        const desktopTargetColumnWidth = 300;
        const mobileTargetColumnWidth = 180;
        const returnEase = 0.03;
        const damping = 0.92;
        const mobileColumnCap = 1;
        const mobileRowPadding = 1;
        const desktopRowPadding = 6;
        const mobileParticleLimit = 420;

        class LetterParticle {
            constructor(char, x, y, columnIndex) {
                this.char = char;
                this.columnIndex = columnIndex;
                this.homeX = x;
                this.homeY = y;
                this.x = x;
                this.y = y;
                this.velX = 0;
                this.velY = 0;
                this.scatterTimer = 0;
            }

            update() {
                const scrollDir = getColumnDirection(this.columnIndex);
                this.homeY += scrollDir * scrollSpeed;

                if (this.homeY > height + rowSpacing) {
                    this.homeY -= totalScrollHeight;
                    this.y -= totalScrollHeight;
                } else if (this.homeY < -rowSpacing) {
                    this.homeY += totalScrollHeight;
                    this.y += totalScrollHeight;
                }

                if (this.scatterTimer > 0) {
                    this.scatterTimer--;
                } else {
                    const dx = this.homeX - this.x;
                    const dy = this.homeY - this.y;
                    const distance = sqrt(dx * dx + dy * dy);

                    if (distance > 0.5) {
                        this.velX += dx * returnEase;
                        this.velY += dy * returnEase;
                    } else {
                        this.x = this.homeX;
                        this.y = this.homeY;
                        this.velX = 0;
                        this.velY = 0;
                    }
                }

                this.velX *= damping;
                this.velY *= damping;

                this.x += this.velX;
                this.y += this.velY;
            }

            scatter(mouseX, mouseY) {
                const dx = this.x - mouseX;
                const dy = this.y - mouseY;
                const distance = sqrt(dx * dx + dy * dy);

                if (distance < 60 && this.scatterTimer === 0) {
                    const angle = atan2(dy, dx);
                    const force = random(8, 24);
                    this.velX += cos(angle) * force;
                    this.velY += sin(angle) * force;
                    this.scatterTimer = 24;
                }
            }

            display() {
                let opacity = 255;

                const fadeTop = rowSpacing * 0.5;
                if (this.homeY < fadeTop) {
                    opacity = map(this.homeY, -rowSpacing * 0.8, fadeTop, 0, 255, true);
                }

                const fadeBottomStart = height - rowSpacing * 0.5;
                if (this.homeY > fadeBottomStart) {
                    opacity = map(this.homeY, fadeBottomStart, height + rowSpacing * 0.8, 255, 0, true);
                }

                fill(255, 255, 255, opacity);
                noStroke();
                text(this.char, this.x, this.y);
            }
        }

        function setup() {
            createCanvas(windowWidth, windowHeight);
            const devicePixelRatioSafe = window.devicePixelRatio || 1;
            const forceLowDensity = windowWidth <= mobileBreakpoint ? 1 : Math.min(devicePixelRatioSafe, 1.5);
            pixelDensity(forceLowDensity);
            frameRate(60);
            fontSize = windowWidth * 0.05;
            fontSize = constrain(fontSize, 28, 110);
            textSize(fontSize);
            textStyle(NORMAL);
            textAlign(CENTER, CENTER);
            prepareFont().then((fontName) => {
                customFont = fontName;
            }).catch(() => {
                console.warn("Falling back to system font");
                customFont = "Helvetica Neue";
            }).finally(() => {
                textFont(customFont);
                fontLoaded = true;
                recalcLayout();
            });
        }

        function prepareFont() {
            if (!("fonts" in document)) {
                return Promise.resolve("Helvetica Neue");
            }
            return document.fonts.load('32px "Comforter Brush"').then(() => {
                return "Comforter Brush";
            });
        }

        function createParticles() {
            particles = [];

            const { centers, totalWidth } = computePhraseLayout();
            const totalColumnsWidth = columnWidth * columns;
            const offsetX = (width - totalColumnsWidth) / 2;
            const isMobile = width <= mobileBreakpoint;
            let budgetReached = false;

            for (let col = 0; col < columns && !budgetReached; col++) {
                const columnCenter = offsetX + columnWidth * col + columnWidth / 2;

                for (let row = 0; row < rowsPerColumn && !budgetReached; row++) {
                    const y = row * rowSpacing;
                    const startX = columnCenter - totalWidth / 2;

                    for (let i = 0; i < centers.length; i++) {
                        const char = phrase[i];
                        const x = startX + centers[i];
                        particles.push(new LetterParticle(char, x, y, col));
                        if (isMobile && particles.length >= mobileParticleLimit) {
                            budgetReached = true;
                            break;
                        }
                    }
                }
            }

            if (typeof window !== "undefined") {
                console.info(
                    `[syxy] particles: ${particles.length} (${columns} columns Ã— ${rowsPerColumn} rows)`
                );
            }
        }

        function draw() {
            background(0);

            for (const p of particles) {
                p.update();
                if (mouseX > 0 && mouseY > 0) {
                    p.scatter(mouseX, mouseY);
                }
                p.display();
            }
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            recalcLayout();
        }

        function recalcLayout() {
            if (!fontLoaded) {
                return;
            }
            const isMobile = width <= mobileBreakpoint;
            const targetColumnWidth = isMobile ? mobileTargetColumnWidth : desktopTargetColumnWidth;
            const estimatedColumns = Math.max(minColumns, Math.round(width / targetColumnWidth));
            columns = constrain(isMobile ? Math.min(estimatedColumns, mobileColumnCap) : estimatedColumns, minColumns, maxColumns);
            columnWidth = width / columns;

            fontSize = columnWidth * (isMobile ? 0.8 : 0.65);
            fontSize = constrain(fontSize, isMobile ? 26 : 42, 220);
            textSize(fontSize);
            textFont(customFont || "Helvetica Neue");

            const spacingFactor = isMobile ? mobileSpacingFactor : desktopSpacingFactor;
            rowSpacing = fontSize * spacingFactor;
            rowsPerColumn = Math.ceil(height / rowSpacing) + (isMobile ? mobileRowPadding : desktopRowPadding);
            totalScrollHeight = rowSpacing * rowsPerColumn;
            createParticles();
        }

        function getColumnDirection(index) {
            return index % 2 === 0 ? 1 : -1;
        }

        function computePhraseLayout() {
            const centers = [];
            let cursor = 0;

            for (let i = 0; i < phrase.length; i++) {
                const charWidth = textWidth(phrase[i]);
                centers.push(cursor + charWidth / 2);
                cursor += charWidth * 0.95;
            }

            return { centers, totalWidth: cursor };
        }
    </script>
</body>
</html>